# IPC-Message Queues

### 9.1. Introduction to IPC (Inter-Process Communication)
IPC (Inter-Process Communication) refers to mechanisms that allow processes to communicate with each other and synchronize their actions. IPC can be categorized into the following main types:

### 9.1.1. Communication Mechanisms
Communication mechanisms focus on data transfer between processes:

#### 9.1.1.1. Data Transfer
- **Byte Stream**
  - **Pipes**: Unidirectional communication channel between related processes (created with `pipe()`)
  - **FIFOs (Named Pipes)**: Similar to pipes but can be used by unrelated processes (created with `mkfifo()`)
  - **Stream Sockets**: Connection-oriented, reliable communication providing sequenced and unduplicated data flow (used for TCP/IP networking)

- **Message**
  - **System V Message Queue**: Older IPC mechanism using integer keys for message exchange
  - **POSIX Message Queue**: Modern IPC mechanism using pathname-style names for message exchange
  - **Datagram Socket**: Connection-less, message-oriented communication with no guarantee of delivery or order (used for UDP/IP networking)

#### 9.1.1.2. Shared Memory
- **System V Shared Memory**: Allows multiple processes to share memory regions (uses `shmget()`, `shmat()`, `shmdt()`, `shmctl()`)
- **POSIX Shared Memory**: Modern API for shared memory with file-based interface (uses `shm_open()`, `mmap()`, `munmap()`, `shm_unlink()`)
- **Memory Mapping**
  - **Anonymous Mapping**: Private memory regions not backed by files
  - **File Mapping**: Maps files into process memory space

### 9.1.2. Synchronization Mechanisms
Synchronization mechanisms coordinate process execution:
- **Semaphore**
  - **System V Semaphore**: Set of counters maintained by the kernel
  - **POSIX Semaphore**
    - **Named**: Can be used by unrelated processes
    - **Unnamed**: Used between related processes or threads

- **File lock**
  - **Record lock (fcntl())**: Locks specific regions of a file
  - **File lock (flock())**: Locks an entire file

- **Thread-specific synchronization**
  - **Mutex (threads)**: Mutual exclusion locks for thread synchronization
  - **Conditional variable (threads)**: Allow threads to wait for specific conditions

<p align="center">
  <img src="https://github.com/user-attachments/assets/3c5fb086-13c9-4faa-8a4c-cade552614a9" alt="Chat App Screenshot" width="500"/>
</p>

### 9.1.3. What are Message Queues?

- A Message Queue is a linked list of messages maintained by the kernel.
- All processes can exchange data by accessing the same queue.
- Each message is tagged with additional information about its type (message type).

<p align="center">
  <img src="https://github.com/user-attachments/assets/c1a13822-d472-4615-9fe7-f45a03c61649" alt="Message Queue Structure" width="500"/>
</p>

- Processes can retrieve appropriate messages based on the message type.

<p align="center">
  <img src="https://github.com/user-attachments/assets/8fd1fa6c-a01b-4cec-b6f5-8e3bf668eb18" alt="IPC Example" width="500"/>
</p>

--- 

## 9.2. System V Message Queues
### 9.2.1. Implementation Steps
1. Create a key
2. Create a message queue or open an existing one
3. Write data to the message queue
4. Read data from the message queue
5. Release the message queue

### 9.2.2. Creating a Key
- The key can be any integer or generated by the `ftok()` function.
```c
#include <sys/ipc.h>

key_t ftok(const char *pathname, int proj);
```
- Returns an integer key on success, or -1 on error.
- `pathname`: Must be an existing, accessible file
- `proj`: A project identifier value (usually a single character)

### 9.2.3. Creating a Message Queue
- To create a new message queue or open an existing one, use `msgget()`.
```c
#include <sys/types.h>
#include <sys/msg.h>

int msgget(key_t key, int msgflg);
```
- Parameters:
  - `key`: Key created in step 1
  - `msgflg`: Control flags
    + `IPC_CREAT`: Create queue if it doesn't exist
    + `IPC_EXCL`: When used with IPC_CREAT, fail if queue already exists
    + Access permission bits (e.g., 0666)
- Returns a message queue identifier on success, or -1 on error.

### 9.2.4. Writing to a Message Queue
- To write data (send/append) to a message queue, use `msgsnd()`.
```c
#include <sys/types.h>
#include <sys/msg.h>

int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
```
- Parameters:
  - `msqid`: Message queue ID obtained from `msgget()`
  - `msgp`: Pointer to the message to send, structured as:
    ```c
    struct msgbuf {
        long mtype;     /* message type, must be > 0 */
        char mtext[1];  /* message data */
    };
    ```
  - `msgsz`: Size of the message data (excluding mtype)
  - `msgflg`: Control flags
    + `IPC_NOWAIT`: Return immediately if the queue is full
    + `0`: Block until space is available
- Returns 0 on success, or -1 on error.

### 9.2.5. Reading from a Message Queue
- To read data from a message queue, use `msgrcv()`.
```c
#include <sys/types.h>
#include <sys/msg.h>

ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
```
- Parameters:
  - `msqid`: Message queue ID obtained from `msgget()`
  - `msgp`: Pointer to the buffer where the message will be stored
  - `msgsz`: Maximum size of the message data to receive
  - `msgtyp`: Message type filter:
    + `0`: Get the first message in the queue
    + `> 0`: Get the first message of the specified type
    + `< 0`: Get the first message with the lowest type less than or equal to the absolute value of msgtyp
  - `msgflg`: Control flags
    + `IPC_NOWAIT`: Return immediately if no message of the requested type is available
    + `MSG_NOERROR`: Truncate message if it's larger than msgsz
- Returns the number of bytes copied into mtext on success, or -1 on error.

### 9.2.6. Deleting a Message Queue
- To control operations on a message queue, use `msgctl()`.
```c
#include <sys/types.h>
#include <sys/msg.h>

int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```
- Parameters:
  - `msqid`: Message queue ID obtained from `msgget()`
  - `cmd`: Command to perform
    + `IPC_RMID`: Remove the message queue immediately
    + `IPC_STAT`: Copy queue information into the structure pointed to by buf
    + `IPC_SET`: Set queue attributes according to the structure pointed to by buf
  - `buf`: Pointer to a msqid_ds structure (can be NULL when using IPC_RMID)
- Returns 0 on success, or -1 on error.

### 9.2.7. Example: System V Message Queue
```c
/* Sender program */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

#define MAX_SIZE 512

// Message structure
struct msg_buffer {
    long msg_type;
    char msg_text[MAX_SIZE];
};

int main() {
    key_t key;
    int msgid;
    struct msg_buffer message;
    
    // Create a key
    key = ftok("message_queue_file", 65);
    
    // Create or open a message queue
    msgid = msgget(key, 0666 | IPC_CREAT);
    
    // Set message type and text
    message.msg_type = 1;
    printf("Enter message to send: ");
    scanf("%[^\n]", message.msg_text);
    
    // Send message
    if (msgsnd(msgid, &message, sizeof(message.msg_text), 0) == -1) {
        perror("msgsnd failed");
        exit(1);
    }
    
    printf("Message sent: %s\n", message.msg_text);
    
    return 0;
}
```

```c
/* Receiver program */
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

#define MAX_SIZE 512

// Message structure
struct msg_buffer {
    long msg_type;
    char msg_text[MAX_SIZE];
};

int main() {
    key_t key;
    int msgid;
    struct msg_buffer message;
    
    // Create a key (same as sender)
    key = ftok("message_queue_file", 65);
    
    // Open the message queue
    msgid = msgget(key, 0666 | IPC_CREAT);
    
    // Receive message
    if (msgrcv(msgid, &message, sizeof(message.msg_text), 1, 0) == -1) {
        perror("msgrcv failed");
        exit(1);
    }
    
    // Display message
    printf("Message received: %s\n", message.msg_text);
    
    // Remove message queue
    msgctl(msgid, IPC_RMID, NULL);
    
    return 0;
}
```
---

## 9.3. POSIX Message Queues
### 9.3.1. Implementation Steps
1. Create a message queue or open an existing one
2. Write data to the message queue
3. Read data from the message queue
4. Close the message queue when not in use
5. Remove the message queue when no longer needed

### 9.3.2. Opening a Message Queue
- To create a new message queue or open an existing one, use `mq_open()`.
```c
#include <fcntl.h>      /* Defines O_ constants */
#include <sys/stat.h>   /* Defines mode constants */
#include <mqueue.h>

mqd_t mq_open(const char *name, int oflag);
mqd_t mq_open(const char *name, int oflag, mode_t mode, struct mq_attr *attr);
```
- Parameters:
  - `name`: Message queue name (must start with a slash, e.g., "/myqueue")
  - `oflag`: Control flags
    + `O_CREAT`: Create queue if it doesn't exist
    + `O_EXCL`: When used with O_CREAT, fail if queue already exists
    + `O_RDONLY`: Open for reading only
    + `O_WRONLY`: Open for writing only
    + `O_RDWR`: Open for both reading and writing
    + `O_NONBLOCK`: Non-blocking operation
  - `mode`: Permission bits (e.g., 0666) when creating a new queue
  - `attr`: Specify queue attributes. If NULL, default attributes are used
- Returns a message queue descriptor on success, or (mqd_t) -1 on error.

- Message queue attributes structure:
```c
struct mq_attr {
    long mq_flags;    /* Message queue descriptor flags: 0 or O_NONBLOCK [mq_getattr(), mq_setattr()] */
    long mq_maxmsg;   /* Maximum number of messages on queue [mq_open(), mq_getattr()] */
    long mq_msgsize;  /* Maximum message size (in bytes) [mq_open(), mq_getattr()] */
    long mq_curmsgs;  /* Number of messages currently in queue [mq_getattr()] */
};
```

### 9.3.3. Sending a Message
- To write data to a message queue, use `mq_send()`.
```c
#include <mqueue.h>

int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned int msg_prio);
```
- Parameters:
  - `mqdes`: Message queue descriptor returned by `mq_open()`
  - `msg_ptr`: Pointer to the message buffer
  - `msg_len`: Length of the message in bytes (must not exceed the queue's mq_msgsize)
  - `msg_prio`: Message priority (unsigned integer, higher value = higher priority)
- Returns 0 on success, or -1 on error.

### 9.3.4. Receiving a Message
- To read data from a message queue, use `mq_receive()`.
```c
#include <mqueue.h>

ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned int *msg_prio);
```
- Parameters:
  - `mqdes`: Message queue descriptor returned by `mq_open()`
  - `msg_ptr`: Pointer to the buffer where the message will be stored
  - `msg_len`: Size of the buffer (must be at least as large as the queue's mq_msgsize)
  - `msg_prio`: Pointer to store the priority of the received message (can be NULL)
- The `mq_receive()` function removes the highest priority message from the queue and returns it in the buffer pointed to by `msg_ptr`.
- Returns the number of bytes in the received message on success, or -1 on error.

### 9.3.5. Closing a Message Queue
- To close a message queue when it's no longer needed, use `mq_close()`.
```c
#include <mqueue.h>

int mq_close(mqd_t mqdes);
```
- Parameters:
  - `mqdes`: Message queue descriptor returned by `mq_open()`
- Returns 0 on success, or -1 on error.
- Note: Closing a message queue doesn't remove it from the system; it just releases the file descriptor.

### 9.3.6. Removing a Message Queue
- To delete a message queue from the system, use `mq_unlink()`.
```c
#include <mqueue.h>

int mq_unlink(const char *name);
```
- Parameters:
  - `name`: Name of the message queue to remove (same format as used with `mq_open()`)
- Returns 0 on success, or -1 on error.
- Note: The queue is not actually removed until all processes that have it open close their descriptors.

### 9.3.7. Example: POSIX Message Queue
```c
/* Sender program */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <mqueue.h>
#include <unistd.h>

#define QUEUE_NAME "/test_queue"
#define MAX_SIZE 1024
#define QUEUE_PERMISSIONS 0660
#define MAX_MESSAGES 10

int main() {
    mqd_t mq;
    struct mq_attr attr;
    char buffer[MAX_SIZE + 1];
    int must_stop = 0;
    
    // Set queue attributes
    attr.mq_flags = 0;
    attr.mq_maxmsg = MAX_MESSAGES;
    attr.mq_msgsize = MAX_SIZE;
    attr.mq_curmsgs = 0;
    
    // Create the message queue
    mq = mq_open(QUEUE_NAME, O_CREAT | O_WRONLY, QUEUE_PERMISSIONS, &attr);
    if (mq == (mqd_t)-1) {
        perror("mq_open");
        exit(1);
    }
    
    do {
        printf("Enter message to send (or empty to quit): ");
        fgets(buffer, MAX_SIZE, stdin);
        
        // Remove trailing newline
        size_t len = strlen(buffer);
        if (len > 0 && buffer[len-1] == '\n')
            buffer[len-1] = '\0';
        
        if (strlen(buffer) == 0) {
            must_stop = 1;
        } else {
            // Send message with priority 1
            if (mq_send(mq, buffer, strlen(buffer) + 1, 1) == -1) {
                perror("mq_send");
                exit(2);
            }
        }
    } while (!must_stop);
    
    // Close the queue
    mq_close(mq);
    
    return 0;
}
```

```c
/* Receiver program */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <mqueue.h>
#include <unistd.h>

#define QUEUE_NAME "/test_queue"
#define MAX_SIZE 1024
#define MAX_MESSAGES 10

int main() {
    mqd_t mq;
    struct mq_attr attr;
    char buffer[MAX_SIZE + 1];
    unsigned int prio;
    
    // Open the message queue
    mq = mq_open(QUEUE_NAME, O_RDONLY);
    if (mq == (mqd_t)-1) {
        perror("mq_open");
        exit(1);
    }
    
    // Get queue attributes
    if (mq_getattr(mq, &attr) == -1) {
        perror("mq_getattr");
        exit(1);
    }
    
    printf("Maximum # of messages on queue: %ld\n", attr.mq_maxmsg);
    printf("Maximum message size: %ld\n", attr.mq_msgsize);
    printf("# of messages currently on queue: %ld\n", attr.mq_curmsgs);
    
    // Receive messages
    while (1) {
        ssize_t bytes_read = mq_receive(mq, buffer, MAX_SIZE, &prio);
        
        if (bytes_read == -1) {
            perror("mq_receive");
            exit(2);
        }
        
        buffer[bytes_read] = '\0';
        
        if (strncmp(buffer, "quit", strlen("quit")) == 0) {
            break;
        }
        
        printf("Received message (priority %u): %s\n", prio, buffer);
    }
    
    // Close and remove the queue
    mq_close(mq);
    mq_unlink(QUEUE_NAME);
    
    return 0;
}
```
---

## 9.4. Comparison Between System V and POSIX Message Queues

| Feature | System V | POSIX |
|---------|----------|-------|
| Naming | Uses integer keys | Uses pathname-style names (e.g., "/myqueue") |
| API | Older, less consistent | Newer, more consistent with other POSIX APIs |
| Notification | Not supported | Supports asynchronous notification |
| Priority | Messages have types | Messages have explicit priorities |
| Timeouts | Not supported | Supports timed send/receive operations |
| Persistence | Persists until explicitly removed | Can be persistent or temporary |
| Max Message Size | System-defined | Can be specified at creation time |
